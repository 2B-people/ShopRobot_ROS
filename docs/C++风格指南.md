# HDU-Shop-Robot C++风格指南

## 0. 前言

### 0.1 版本

2018.10.30  #001 初步完成，的我们应该在实践中修改此文档，使其能够很好适应该项目的开发。
2019.1.29   #002 成员开始使用此文档规范代码风格

### 0.2 背景

C++是ROS的主要编程语言之一。正如每个c++开发者所知，c++是一种十分强大的语言，但它的强大必然导致它走向复杂，使得代码出现BUG，使其变的难以维护，晦涩难懂。

因此，在一个团队中，统一代码风格是十分重要的。使用统一且具有描述性的标识符，以及相似的代码风格，对于其它开发者来说是一种福音，因为，统一，具有描述性的编程风格能人以一种“模式匹配”的思维模式来理解代码，这样大大加强了后来维护者的工作效率。同时，在特定场景下，这些编程风格可能不适应需求，我们不反对你违背这些指南，但尽量不要这么去做。

HDU-Shop-Robot（杭电购物机器人）作为开源项目，需要每一位成员贡献自己的代码，如果编程风格不统一，会让其他模块的队友感到困惑，甚至引起BUG。我们认为为该项目编写代码的一系列约定是非常有必要的.当所有代码均保持一致的风格, 在学弟们再次使用这套代码，能够快速入手，快速复用，也是对实验室的一个非常好的遗产。

## 1. 头文件

通常每一个 `.cpp` 文件都有一个对应的 `.h` 文件. 也有一些常见例外, 如单元测试代码和只包含 `main()` 函数的 `.cpp` 文件.

正确使用头文件可令代码在可读性、文件大小和性能上大为改观.

### 1.1 #define 保护

> **Tip**
>
> 所有头文件都应该使用 `#define` 来防止头文件被多重包含, 命名格式当是: `<PATH>_<NAME>_H_` .

为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 `shoprobot_stm32` 中的头文件 `shoprobot\imu_calib\include\imu_calib\accel_calib.h` 可按如下方式保护:

```cpp
#ifndef IMU_ACCELCALIB_H_
#define IMU_ACCELCALIB_H_
...
#endif // IMU_ACCELCALIB_H_
```

### 1.2 #include的路径及顺序

> **Tip**
>
> 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.

项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 `.` (当前目录) 或 `..` (上级目录). 例如, `google-awesome-project/src/base/logging.h` 按如下方式包含: 

```cpp
#include "base/logging.h"
```

关于`#include`的顺序，`.c` `.h`同样适合使用，但大都是尽量写在`.h`的中，然后`.c`文件只用引用与之对应的`.h`文件，`#include`的次序如下：

1. ROS系统的文件
2. C系统文件
3. C++系统文件
4. 其他库的`.h`文件
5. 本项目内`.h`文件

在 `#include` 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 `.h` 和本项目内的 `.h` 是个好习惯。

举例来说，头文件包含次序如下（源码来自西北关于大学home组）：

```
#include <ros/ros.h> 
#include <ros/callback_queue.h>
#include <hardware_interface/robot_hw.h> 
#include <hardware_interface/joint_command_interface.h> 
#include <hardware_interface/joint_state_interface.h>
#include <controller_manager/controller_manager.h>
#include <realtime_tools/realtime_buffer.h>
#include <realtime_tools/realtime_publisher.h>
#include <std_msgs/Float64.h>
 
#include <sstream> 
#include <vector>
#include <string>
#include <map> 

#include <xm_arm_msgs/xm_ArmSerialDatagram.h> 

#include <boost/shared_ptr.hpp>
```

> 注：`.hpp`文件为可以将`.cpp`的代码可以混入头文件中的一种特殊的`.h`

## 2. 作用域

### 2.1 命名空间

> **Tip**
>
> 鼓励在 `.cc` 文件内使用匿名命名空间或 `static` 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。

**定义:**

命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突。

**优点：**

虽然类已经提供了（可嵌套的）命名轴线 ( 注: 将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层.举例来说, 两个不同项目的全局作用域都有一个类 `Foo`, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, `project1::Foo` 和 `project2::Foo` 作为不同符号自然不会冲突。

**缺点：**

+ 命名空间具有迷惑性, 因为它们使得区分两个相同命名所指代的定义更加困难。

+ 内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。

+ 有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。

+ 在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).

**结论：**

根据下文提到的策略合理使用命名空间。

#### 2.1.1 匿名命名空间和静态变量

+ 在`.cpp`文件中，我们支持鼓励使用匿名命名空间来保护编译时的发送的命名冲突
+ 函数和变量可以经由声明为 `static` 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。
+ 但是千万不要在`.h`内使用匿名命名空间
+ 匿名命名空间的声明和具名的格式相同，在最后注释上 `namespace` :

```cpp
namespace {
...
}  // namespace
```

#### 2.1.2 具体的名字空间

用命名空间把文件包含的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:

```cpp
// .h 文件
namespace mynamespace {

// 所有声明都置于命名空间中
// 注意不要使用缩进
class MyClass {
    public:
    ...
    void Foo();
};

} // namespace mynamespace
```

```cpp
// .cpp 文件
namespace mynamespace {

// 函数定义都置于命名空间中
void MyClass::Foo() {
    ...
}

} // namespace mynamespace// .cpp文件
namespace mynamespace {

// 函数定义都置于命名空间中
void MyClass::Foo() {
    ...
}

} // namespace mynamespace
```

#### 2.1.3 禁止使用

+ 禁止使用 *using 指示* 引入整个命名空间的标识符号。
+ 禁止用内联命名空间

### 2.2 非成员函数，静态成员函数和全局函数

>**Tip**
>
>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.

**优点:**

 某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域.

**缺点:**

将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.

**结论:**

有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 2.1. 命名空间) 。举例而言，对于头文件 `myproject/foo_bar.h` , 应当使用

```cpp
namespace myproject{
    namespace foo_bar{
        void Function();
        void FUnction();
    }//namespace foo_bar
} // namespace myproject
```

而非使用一个类来封装这两个函数。

如果你必须定义非成员函数, 又只是在 `.cc` 文件中使用它, 可使用 2.1. 1匿名命名空间 或 `static` 链接关键字 (如 `static int Foo() {...}`) 限定其作用域.

### 2.3 全局变量

>**Tip**
>
>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.

C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:

```cpp
int i;
i = f(); // 坏——初始化和声明分离
```

```cpp
int j = g(); // 好——初始化时声明
```

```cpp
vector<int> v;
v.push_back(1); // 用花括号初始化更好
v.push_back(2);
```

```cpp
vector<int> v = {1, 2}; // 好——v 一开始就初始化
```

> **! Warning**
>
> 有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.

```cpp
// 低效的实现
for (int i = 0; i < 1000000; ++i) {
    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
}
```

在循环作用域外面声明这类变量要高效的多: 

```cpp
Foo f;                      // 构造函数和析构函数只调用 1 次
for (int i = 0; i < 1000000; ++i) {
    f.DoSomething(i);
}
```

### 2.4 静态和全局变量

// TODO 暂时看不懂，等待能够理解的时候在转到文档上

[google开源项目指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/)

## 3 类

类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.

### 3.1 构造函数的职责

> **Tip**
>
> 不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化,构造函数仅仅进行**最简单的初始化操作**。

**定义**

在构造函数中可以进行各种初始化操作.

**优点**

- 无需考虑类是否被初始化.
- 经过构造函数完全初始化后的对象可以为 `const` 类型, 也能更方便地被标准容器或算法使用.

**缺点**

- 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.
- 在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被禁用) 了) 等方法的条件下, 构造函数很难上报错误
- 如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 `bool isValid()` 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.
- 构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.

**结论**

+ 构造函数尽量简单；

+ 构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 `Init()` 方法或工厂函数.

+ 构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 `Init() `方法或使用工厂模式. Avoid `Init()` methods on objects with no other states that affect which public methods may be called (此类形式的半构造对象有时无法正确工作).(不懂)

###  3.2 初始化



### 3.3 声明顺序

> **Tip**
>
> 将相似的声明放在一起, 将 `public` 部分放在最前.

**说明**

类定义一般应以

1. `public:` 开始, 
2. 后跟 `protected:`, 
3. 最后是 `private:`. 省略空部分.

在各个部分中, 建议将类似的声明放在一起, 每个区段内的声明通常按以下顺序：

1.  `typedefs`和枚举
2.  常量
3.  构造函数
4.  析构函数
5.  成员函数，含静态成员函数
6.  数据成员，含静态数据成员

`.cpp`文件中函数的定义应尽可能和声明顺序一致。

### 3.4 结构体 VS 类

>**Tip**
>
>仅当只有数据成员时使用 `struct`, 其它一概使用 `class`.

**说明**

在 C++ 中 `struct` 和 `class` 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字.

`struct` 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, `Initialize()`, `Reset()`, `Validate()` 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.

如果需要更多的函数功能, `class` 更适合. 如果拿不准, 就用 `class`.

为了和 STL 保持一致, 对于仿函数等特性可以不用 `class` 而是使用 `struct`.

注意: 类和结构体的成员变量使用不同的[命名规则]().

### 3.5 继承

>**Tip**
>
>使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 `public` 继承.

**定义**

当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称.

**优点**

实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.

**缺点**

对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局.

**结论**

+ 所有继承必须是`public`的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.

+ 不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在“是一个”的情况下使用继承: 如果`Bar`的确 “是一种” `Foo`,`Bar`才能继承`Foo`.
  
+ 必要的话, 析构函数声明为`virtual`. 如果你的类有虚函数, 则析构函数也应该为虚函数.
  
+ 对于可能被子类访问的成员函数, 不要过度使用 protected 关键字. 注意, 数据成员都必须是私有的.

## 4 函数

### 4.1 参数顺序

>**Tip**
>
>函数的参数顺序为：输入参数在先，后跟着输出参数。

**说明**

C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或`const`引用, 输出参数或输入/输出参数则一般为非`const`指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.
这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.

### 4.2 编写简短函数

>**Tip**
>
>我们倾向于编写简短, 凝练的函数.

**说明**

我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.
即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.
在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.

### 4.3 函数重载

>**Tip**
>
>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.

**定义**

你可以编写一个参数类型为 `const string&` 的函数, 然后用另一个参数类型为 `const char*` 的函数对其进行重载:

```c++
class MyClass {
    public:
    void Analyze(const string &text);
    void Analyze(const char *text, size_t textlen);
}
```

**优点**

通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.

**缺点** 

如果函数单靠不同的参数类型而重载 (这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.

**结论** 

如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 `AppendString()` 和 `AppendInt()` 等, 而不是一口气重载多个 `Append()`. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 `std::vector` 以便使用者可以用 [列表初始化](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#braced-initializer-list) 指定参数.

## 5 一些C++特性

###  5.1 流

>**Tip**
>
>我们只在记录日志时使用流

定义:

 流用来替代 `printf()` 和 `scanf()`.

优点:

 有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 `printf` 也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.

缺点:

流使得 `pread()` 等功能函数很难执行. 如果不使用 `printf` 风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 `%.*s`) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用. 

结论:

**不要使用流**, 除非是日志接口需要. 使用 `printf` 之类的代替.

使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.

拓展讨论:

对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是 `printf + read/write`. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.

### 5.2 前置自增和自减

>**Tip**
>
>对于迭代器和其他模板对象使用前缀形式 (`++i`) 的自增, 自减运算符.

定义:

对于变量在自增 (`++i` 或 `i++`) 或自减 (`--i` 或 `i--`) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).

优点:

不考虑返回值的话, 前置自增 (`++i`) 通常要比后置自增 (`i++`) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 `i` 进行一次拷贝. 如果 `i` 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?

缺点:

在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 `for` 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (`i`) 在谓语动词 (`++`) 前.

结论:

对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).

###  5.3 auto

>**Tip**
>
>用 `auto` 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方

定义：

C++11 中，若变量被声明成 `auto`, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用 `auto` 来复制初始化或绑定引用。

```c++
vector<string> v;
...
auto s1 = v[0];  // 创建一份 v[0] 的拷贝。
const auto& s2 = v[0];  // s2 是 v[0] 的一个引用。
```

优点：

C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：

```c++
sparse_hash_map<string, int>::iterator iter = m.find(val);
```

返回类型好难读，代码目的也不够一目了然。重构其

```c++
auto iter = m.find(val);
```

结论：

`auto` 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 `auto` 变量。

`auto` 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。

### 5.4 类型转换

>**Tip**
>
>使用 C++ 的类型转换, 如 `static_cast<>()`. 不要使用 `int y = (int)x` 或 `int y = int(x)` 等转换方式;

**定义**:

C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类. 

**优点**:

C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 `(int)3.5`), 有时是在做类型转换 (如 `(int)"hello"`). 另外, C++ 的类型转换在查找时更醒目. 

**缺点**:

恶心的语法. 

**结论**: 

不要使用 C 风格类型转换. 而应该使用 C++ 风格.

* 用 `static_cast` 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.

* 用 `const_cast` 去掉 `const` 限定符.

* 用 `reinterpret_cast` 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.

## 6 命名约定

最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: *类型*, *变量*,*函数*, *常量*, *宏*,等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.

命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.

> **总述**
>
> 函数命名, 变量命名, 文件命名要有描述性; 少用缩写.

**注意**, 一些特定的广为人知的缩写是允许的, 例如用 `i` 表示迭代变量和用 `T` 表示模板参数.

### 6.1 文件命名

>**Tip**
>
>文件名要全部小写, 可以包含下划线 (`_`) 或连字符 (`-`), 依照项目的约定. 如果没有约定, 那么 “`_`” 更好.

**说明**

可接受的文件命名示例:

- `my_useful_class.cc`
- `my-useful-class.cc`
- `myusefulclass.cc`
- `myusefulclass_test.cc` // `_unittest` 和 `_regtest` 已弃用.

C++ 文件要以 `.cpp` 结尾, 头文件以 `.h` 结尾. 专门插入文本的文件则以 `.inc` 结尾, 参见 头文件

不要使用已经存在于 `/usr/include` 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 `db.h`.

通常应尽量让文件名更加明确. `http_server_logs.h` 就比 `logs.h` 要好. 定义类时文件名一般成对出现, 如 `foo_bar.h` 和 `foo_bar.cc`, 对应于类 `FooBar`.

内联函数必须放在 `.h` 文件中. 如果内联函数比较短, 就直接放在 `.h` 中.

###  6.2 类型命名

> **Tip**
>
> 驼峰命名法,类型名称的每个单词首字母均大写, 不包含下划线: `MyExcitingClass`, `MyExcitingEnum`.

**说明**

所有类型命名 —— 类, 结构体, 类型定义 (`typedef`), 枚举, 类型模板参数 —— **均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线**. 例如:

```c++
// 类和结构体
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// 类型定义
typedef hash_map<UrlTableProperties *, string> PropertiesMap;

// using 别名
using PropertiesMap = hash_map<UrlTableProperties *, string>;

// 枚举
enum UrlTableErrors { ...
```

###  6.3 变量命名

> **Tip**
>
> 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: `a_local_variable`, `a_struct_data_member`, `a_class_data_member_`.

**说明**

**普通变量命名**

举例:

```c++
string table_name;  // 好 - 用下划线.
string tablename;   // 好 - 全小写.

string tableName;  // 差 - 混合大小写
```

**类数据成员**

不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要**接下划线**.

```c++
class TableInfo {
  ...
 private:
  string table_name_;  // 好 - 后加下划线.
  string tablename_;   // 好.
  static Pool<TableInfo>* pool_;  // 好.
};
```

**结构体变量**

不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:

```c++
struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool<UrlTableProperties>* pool;
};
```

###  6.4 常量命名

> **Tip**
>
> 声明为 `constexpr` 或 `const` 的变量, 或在程序运行期间其值始终保持不变的, 命名时以**k**开头, 大小写混合. 例如:

```c++
const int kDaysInAWeek = 7;
```

### 6.5 函数命名

>**Tip**
>
>对函数命名是我们也使用驼峰命名法， 即以大写字母开始, 每个单词首字母均大写, 不包含下划线，但与类型不同的一点是，用一个全小写的动词来描述函数

**说明**

一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线.用一个全小写的动词来描述函数、 (例如, 写作 `startRpc()` 而非 `StartRPC()`).

```c++
addTableEntry();
delEteUrl();
openFileOrDie();
```

###  6.6 命名空间命名

> **Tip**
>
> 命名空间尽量简单，用最少的字母描述这个命名空间是用在什么地方的

**说明**

命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.

顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.

注意 不使用缩写作为名称 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.

 要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 `std` 命名空间. 建议使用更独特的项目标识符 (`websearch::index`, `websearch::index_util`) 而非常见的极易发生冲突的名称 (比如 `websearch::util`).

对于 `internal` 命名空间, 要当心加入到同一 `internal` 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 `frobber.h`, 使用 `websearch::index::frobber_internal`).

**结论**

命名空间尽量简单，用最少的字母描述这个命名空间是用在什么地方的。

### 6.7 枚举和宏

> **Tip**
>
> 枚举和宏均使用大写字母，加上`_`连接单词

**说明**

参考预处理宏; 通常不应该使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线`_`:

```c++
#define ROUND(x) 
#define PI_ROUNDED 3.0
```

## 7 注释

注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.
你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你!

>**Tip**
>我们推荐使用 `//`

### 7.1 类注释

>**Tip**
>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.

```c++
// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table->NewIterator();
//    for (iter->Seek("foo"); !iter->done(); iter->Next()) {
//      process(iter->key(), iter->value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
```

**说明**

类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明.
如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适.
如果类的声明和定义分开了(例如分别放在了 .h 和 .cpp 文件中), 此时,描述类用法的注释和类的操作和实现的注释应当放在`.h`里。

### 7.2 函数注释

>**Tip**
>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.

在函数声明处使用`//`注释，用一句话来描述函数功能，eg：

```c++
//判断两数的大小
judNum(int a, int b);
```

在定义处具体写出函数的简述，参数，返回值，作者，eg：

```c++
//
// @brief <简述>
// -<具体实现，可不加>
// @param <参数说明>
// - <参数的特定要求，可不加>
// - 
// -
// -
// @author
// - <作者名字><联系方式>

例：
//
// @brief 重新设定PID的参数
// @param Kp pid的p值
// @param Ki pid的i值
// @param Kd pid的d值
// @author
// - 那清权<nqq0915@163.com>
void PID::resetPID(float kp, float ki, float kd)
{
    PID->Kp_ = Kp;
    PID->Ki_ = Ki;
    PID->Kd_ = Kd;

    PID->Err_[NOW] = PID->Err_[LAST] = PID->Err_[LLAST] = 0;

    PID->Pout_ = 0;
    PID->Iout_ = 0;
    PID->Dout_ = 0;
    PID->Out_ = 0;
}
```

### 7.3 变量注释

>**Tip**
>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.

**全局变量**

全局变量推荐使用注释，强调其的重要性

### 7.4 TODO注释

>**Tip**
>我们推荐使用TODO注释来表诉需要做的事情
>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用`TODO`注释.

我们推荐三种`TODO`的注释方法：
```c++
1，
// TODO(nqq) 实现巡线功能
2，
// FIXMA(bug 123) 代码存在错误需要更改
3，
// XXX(nqq0915@163.com) 虽然实现了功能，但是实现的方法有待商榷，希望将来能改进
```

## 8 结束语
>**Tip**
>运用常识和判断力, 并且 保持一致.

编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 if 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做.
风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏, 所以要尽量避免.
好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!